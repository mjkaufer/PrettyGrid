<html>
<head>
<style>
	@import url(http://fonts.googleapis.com/css?family=Lato);

	body {
		background-color: #000000;
		margin: 0px;
		overflow: hidden;
		color:white;
		font-family: 'Lato', sans-serif;

	}
</style>
</head>
<body style="background-color:#000;">
		<script src="three.min.js"></script>	
		<script src="TrackballControls.js"></script>


		<script>

			var container, stats;
			var camera, scene, renderer, group, geometry, line;

			var particles, lines;
			var material3, lineMat;

			var mouseX = 0, mouseY = 0;
			var windowHalfX = window.innerWidth / 2;
			var windowHalfY = window.innerHeight / 2;
			var dPoint;
			var tempArray = new Array();
			var c = ['x', 'y', 'z'];
			var count = 0;
			var moveDist = 0.1;
			var neighborAmount = 3;			
			var size = 2.5;
			var spacing = 100;
			var amt = 20;

			for(var x = 0; x < 20; x++){
				var temp = new THREE.Particle;
				var tp = temp.position;
				tp.x = tp.y = tp.z = x;
				tempArray.push(temp);
			}

			//z is depth, so it should be constant
			init();
			animate();

			function avgPosition(pA){//finds the average position of particles in a Vector3, useful to find where the particle will be moving
				var retPos = new THREE.Vector3();
				for(var i = 0; i < pA.length; i++)
					retPos.add(pA[i].position);
				// var randPos = parseInt(Math.round(Math.random()) * 2 - 1);//either a positive or a negative
				retPos.divideScalar(pA.length/* * randPos*/);//only way I can make sure it doesn't stay floating towards the goddamn middle
				return retPos;
			}
			function dist(p1, p2){
				return p1.position.distanceToSquared(p2.position);//no square root, saves time
			}
			function dSort(a, b){//sorts pA in order of particles nearest to p
				return dist(a, dPoint) - dist(b, dPoint);
			}
			function closestParticles(p, pA, amount){//finds {{amount}} closest particles to {{p}} from {{pA}}, returned in an array
				dPoint = p;
				var sortArr = pA = pA.slice(0);//copy of pA
				var pindex = sortArr.indexOf(p);
				sortArr.splice(pindex, pindex);//removes original thing from array, if it's there (which it should be)
				sortArr.sort(dSort);
				sortArr.splice(amount);//so now sortArr only has {{amount}} elements in it, and they all should be the closest to {{p}}
				return sortArr;
			}
			function moveTo(p, v, max){//moves particle p towards vector3 v by max units
				if(count == 0)
					console.log(v)

				var scaleThing = Math.log(parseInt(p.uuid.split("-")[0], 16)) * 20;//a way of implementing a dynamic switch from positive to negative because math hates me
				while(scaleThing < 100)
					scaleThing *= 1.25;//so it's not too small

				var mag = Math.sqrt(v.x * v.x + v.y * v.y + v.z * v.z);
				v.multiplyScalar(max / mag);
				var sign = count % scaleThing < scaleThing / 2.0 ? -1 : 1;
				v.multiplyScalar(sign);


				p.position.add(v);//now p has moved!

			}

			// function vectorToColor(v, m){//v is vector, m is what we'll mod/divide by

			// 	var rgb = [0,0,0];
			// 	for(var f in c){
			// 		var col = (Math.abs(v[c[f]]) % 50 / 50);//can't have negative colors
			// 		if(col < 0.1)//too dark
			// 			col = 1 - col;
			// 		rgb[f] = col;
			// 	}

			// 	return new THREE.Color().setRGB(rgb[0], rgb[1], rgb[2]);
			// }

			function vectorToColor(v, m){//v is vector, m is what we'll mod/divide by

				var mag = 0;
				
				for(var f in c)
					mag+= Math.pow(v[c[f]],2);

				var h = mag % m / m;

				return new THREE.Color().setHSL(h, 0.5, 0.5);
			}			

			function init() {
				container = document.createElement( 'div' );
				document.body.appendChild( container );
				camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 1, 3000 );
				camera.position.z = 200;
				controls = new THREE.TrackballControls( camera );				
				scene = new THREE.Scene();
				var PI2 = Math.PI * 2;
				particles = new THREE.Object3D();
				lines = new THREE.Object3D();
				scene.add( particles );
				scene.add( lines );
				material3 = new THREE.ParticleCanvasMaterial( {
					color: 0x20F050,
					program: function ( context ) {
						context.beginPath();
						context.arc( 0, 0, 1, 0, PI2, true );
						context.fill();
					}
				} );
				lineMat = new THREE.LineBasicMaterial({
					color: 0x20FF60
				});
				renderer = new THREE.CanvasRenderer();
				renderer.setSize( window.innerWidth, window.innerHeight );
				container.appendChild( renderer.domElement );



				for(var x = 0; x < amt; x++){
					var part = new THREE.Particle(material3.clone());//so we can do individual color stuff
					part.scale.x = part.scale.y = size;
					part.position.x = Math.random() * spacing - spacing / 2.0;
					part.position.y = Math.random() * spacing - spacing / 2.0;
					part.position.z = Math.random() * spacing - spacing / 2.0;					
					particles.add(part);
				}


				document.addEventListener( 'mousemove', onDocumentMouseMove, false );
				document.addEventListener( 'touchstart', onDocumentTouchStart, false );
				document.addEventListener( 'touchmove', onDocumentTouchMove, false );
				window.addEventListener( 'resize', onWindowResize, false );
			}
			function onWindowResize() {
				windowHalfX = window.innerWidth / 2;
				windowHalfY = window.innerHeight / 2;
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				renderer.setSize( window.innerWidth, window.innerHeight );
			}
			function onDocumentMouseMove( event ) {
				mouseX = event.clientX - windowHalfX;
				mouseY = event.clientY - windowHalfY;
			}
			function onDocumentTouchStart( event ) {
				if ( event.touches.length === 1 ) {
					event.preventDefault();
					mouseX = event.touches[ 0 ].pageX - windowHalfX;
					mouseY = event.touches[ 0 ].pageY - windowHalfY;
				}
			}
			function onDocumentTouchMove( event ) {

				if ( event.touches.length === 1 ) {
					event.preventDefault();
					mouseX = event.touches[ 0 ].pageX - windowHalfX;
					mouseY = event.touches[ 0 ].pageY - windowHalfY;
				}
			}
			function animate() {
				requestAnimationFrame( animate );
				render();
			}
			function render() {
				camera.lookAt( scene.position );
				controls.update();


				lines.children = [];
				if(window.debug)
				{
					var vertCopy = particles.children.slice(0);//copy so we don't get current changes mucking stuff up


					for(var x = 0; x < particles.children.length; x++){
						var p = particles.children[x];
						var neighbors = closestParticles(p, vertCopy, neighborAmount);
						var moveTowards = avgPosition(neighbors);//average position of p's three neighbors
						moveTo(p, moveTowards, moveDist);
						p.material.color = vectorToColor(p.position, 5000);
					}

					for(var x = 0; x < particles.children.length; x++){
						var p = particles.children[x];

						var neighbors = closestParticles(p, particles.children, neighborAmount);							
						for(var y = 0; y < neighbors.length; y++){
						
							var tempGeo = new THREE.Geometry();
							tempGeo.vertices.push(p.position);
							tempGeo.vertices.push(neighbors[y].position);
							var line = new THREE.Line(tempGeo, lineMat);
							lines.add(line);
						}		
					}
			
				}

				count++;
				renderer.render( scene, camera );

			}

		</script>

</body>
</html>